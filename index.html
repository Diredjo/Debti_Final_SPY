<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debate Timer Final SPY</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f4ff 0%, #e6f0ff 100%);
            min-height: 100vh;
        }
        
        .timer-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .timer-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
        }
        
        .timer-running {
            animation: pulse 2s infinite;
        }
        
        .timer-finished {
            animation: highlight 1.5s ease;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(37, 99, 235, 0); }
            100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
        }
        
        @keyframes highlight {
            0% { background-color: #fef3c7; }
            100% { background-color: #ffffff; }
        }
        
        .beep-btn {
            transition: all 0.2s ease;
        }
        
        .beep-btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>
<body class="py-8 px-4">
    <div class="max-w-6xl mx-auto">
        <!-- Header -->
        <header class="flex flex-col md:flex-row justify-between items-center mb-8 p-6 bg-white rounded-xl shadow-md">
            <div>
                <h1 class="text-2xl md:text-3xl font-bold text-gray-800">Debate Timer Final SPY</h1>
                <p class="text-gray-600 mt-2">Timer untuk debat dengan suara whistle sebagai penanda waktu</p>
            </div>
            <div class="mt-4 md:mt-0">
                <div class="text-xl font-semibold text-blue-600 bg-blue-50 py-2 px-4 rounded-lg">
                    <span id="liveClock">--:--:--</span>
                </div>
            </div>
        </header>

        <!-- Timer Container -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8" id="timersContainer">
            <!-- Timers will be generated here -->
        </div>

        <!-- Footer -->
        <footer class="bg-white p-6 rounded-xl shadow-md">
            <h2 class="text-lg font-semibold text-gray-800 mb-3">Cara Penggunaan:</h2>
            <ul class="list-disc list-inside text-gray-600 space-y-2">
                <li>Tekan <span class="font-medium">Start</span> - timer akan langsung berbunyi whistle pendek (1.2 detik)</li>
                <li>Pada sisa 10 detik - akan terdengar 2x bunyi whistle pendek (terpisah 300ms)</li>
                <li>Pada waktu habis - akan terdengar bunyi whistle panjang (5 detik)</li>
                <li>Tombol <span class="font-medium">Pause/Resume</span> menjaga jadwal beep tanpa duplikasi</li>
            </ul>
        </footer>
    </div>

    <script>
        // Live Clock
        function updateLiveClock() {
            const now = new Date();
            document.getElementById("liveClock").textContent = now.toLocaleTimeString("id-ID");
        }
        setInterval(updateLiveClock, 1000);
        updateLiveClock();

        // Sound Functions (whistle-like) dengan durasi diperpanjang
        class WhistleBeep {
            constructor() {
                this.ctx = null;
            }
            
            init() {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) {
                    console.warn('WebAudio not supported in this browser.');
                    return;
                }
                this.ctx = new AudioContext();
            }
            
            play(type = "short") {
                this.init();
                if (!this.ctx) return;
                
                const ctx = this.ctx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();

                osc.connect(gain);
                gain.connect(ctx.destination);

                osc.type = "square";
                osc.frequency.value = 1000;

                // Durasi suara
                let duration = 1.2; // short beep
                if (type === "double") duration = 1.5; // double beep
                if (type === "long") duration = 5.0;   // long beep (5 detik)

                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + duration);
            }
        }

        const beep = new WhistleBeep();

        // Timer class
        class DebateTimer {
            constructor(opts) {
                this.id = opts.id;
                this.label = opts.label;
                this.duration = opts.duration; // seconds
                this.remaining = this.duration * 1000; // ms
                this.state = 'idle'; // idle, running, paused, finished
                this.intervalHandle = null;
                this.tickInterval = 200; // ms update UI
                this.onTick = opts.onTick || function(){};
                this.onFinish = opts.onFinish || function(){};
                this.timeoutHandles = []; // scheduled beep timeouts
                this.flags = { startPlayed:false, tenSecPlayed:false, endPlayed:false };
                this.lastStartTimestamp = null; // performance.now() when started/resumed
                this.element = null;
                this.createUI();
            }

            createUI() {
                const container = document.getElementById('timersContainer');
                const card = document.createElement('div');
                card.className = 'timer-card bg-white rounded-xl p-6 shadow-md';
                card.innerHTML = `
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">${this.label}</h3>
                    <p class="text-sm text-gray-600 mb-4">Durasi: <span class="font-medium">${this.duration} detik</span></p>
                    <div class="text-3xl font-bold text-center py-4 mb-4 bg-gray-50 rounded-lg" id="${this.id}-time">--:--</div>
                    <div class="flex flex-wrap gap-2 mb-4" id="${this.id}-controls"></div>
                    <div class="mb-3" id="${this.id}-status">
                        <span class="inline-block px-3 py-1 rounded-full text-xs font-semibold bg-yellow-100 text-yellow-800">IDLE</span>
                    </div>
                    <div class="text-xs text-gray-500" id="${this.id}-events"></div>
                `;
                container.appendChild(card);
                this.element = card;
                this.timeEl = card.querySelector(`#${this.id}-time`);
                this.controlsEl = card.querySelector(`#${this.id}-controls`);
                this.statusEl = card.querySelector(`#${this.id}-status`);
                this.eventsEl = card.querySelector(`#${this.id}-events`);

                // Build controls
                const btnStart = this.mkButton('Start', 'bg-blue-500 hover:bg-blue-600 text-white', ()=>this.start());
                const btnPause = this.mkButton('Pause', 'bg-gray-500 hover:bg-gray-600 text-white', ()=>this.pause());
                const btnResume = this.mkButton('Resume', 'bg-green-500 hover:bg-green-600 text-white', ()=>this.resume());
                const btnReset = this.mkButton('Reset', 'bg-red-500 hover:bg-red-600 text-white', ()=>this.reset());
                const btnPlayStart = this.mkButton('Start Beep', 'bg-purple-500 hover:bg-purple-600 text-white', ()=>this.playStartBeep());
                const btnPlayTen = this.mkButton('10s Beep', 'bg-indigo-500 hover:bg-indigo-600 text-white', ()=>this.playTenSecBeep());
                const btnPlayEnd = this.mkButton('End Beep', 'bg-pink-500 hover:bg-pink-600 text-white', ()=>this.playEndBeep());

                [btnStart, btnPause, btnResume, btnReset, btnPlayStart, btnPlayTen, btnPlayEnd].forEach(b=>this.controlsEl.appendChild(b));
                this.updateUI();
            }

            mkButton(label, cls, cb) {
                const b = document.createElement('button');
                b.textContent = label;
                b.className = `px-3 py-2 rounded-lg text-sm font-medium transition ${cls} beep-btn`;
                b.addEventListener('click', cb);
                return b;
            }

            formatRemaining(ms) {
                if (ms < 0) ms = 0;
                const s = Math.ceil(ms/1000);
                const mm = Math.floor(s/60);
                const ss = s % 60;
                return `${mm}:${ss.toString().padStart(2,'0')}`;
            }

            updateUI() {
                this.timeEl.textContent = this.formatRemaining(this.remaining);
                
                // Update status indicator
                let statusClass, statusText;
                if (this.state === 'idle') {
                    statusClass = 'bg-yellow-100 text-yellow-800';
                    statusText = 'IDLE';
                    this.element.classList.remove('timer-running', 'timer-finished');
                } else if (this.state === 'running') {
                    statusClass = 'bg-green-100 text-green-800';
                    statusText = 'RUNNING';
                    this.element.classList.add('timer-running');
                    this.element.classList.remove('timer-finished');
                } else if (this.state === 'paused') {
                    statusClass = 'bg-gray-100 text-gray-800';
                    statusText = 'PAUSED';
                    this.element.classList.remove('timer-running', 'timer-finished');
                } else if (this.state === 'finished') {
                    statusClass = 'bg-blue-100 text-blue-800';
                    statusText = 'FINISHED';
                    this.element.classList.remove('timer-running');
                    this.element.classList.add('timer-finished');
                }
                
                this.statusEl.innerHTML = `<span class="inline-block px-3 py-1 rounded-full text-xs font-semibold ${statusClass}">${statusText}</span>`;
                
                // Update events info
                const evs = [
                    `Start: ${this.flags.startPlayed ? '✓' : '✗'}`,
                    `10s: ${this.flags.tenSecPlayed ? '✓' : '✗'}`,
                    `End: ${this.flags.endPlayed ? '✓' : '✗'}`
                ];
                this.eventsEl.innerHTML = evs.join(' • ');
            }

            scheduleBeepAt(relMs, fn) {
                if (relMs < 0) return;
                const handle = setTimeout(()=>{
                    fn();
                    this.timeoutHandles = this.timeoutHandles.filter(h=>h !== handle);
                }, relMs);
                this.timeoutHandles.push(handle);
            }

            clearScheduled() {
                this.timeoutHandles.forEach(h=>clearTimeout(h));
                this.timeoutHandles = [];
            }

            start() {
                if (this.state === 'running') return;
                if (this.state === 'finished' || this.state === 'idle') {
                    this.flags = { startPlayed:false, tenSecPlayed:false, endPlayed:false };
                    this.remaining = this.duration * 1000;
                }
                this.state = 'running';
                this.lastStartTimestamp = performance.now();
                if (!this.flags.startPlayed) {
                    this.playStartBeep();
                    this.flags.startPlayed = true;
                }
                this.clearScheduled();
                this._scheduleFromNow();
                this._startTick();
                this.updateUI();
            }

            _scheduleFromNow() {
                const rem = this.remaining;
                const tenMs = 10000;
                if (!this.flags.tenSecPlayed && rem > tenMs) {
                    this.scheduleBeepAt(rem - tenMs, ()=> {
                        this.playShortBeep();
                        setTimeout(()=> this.playShortBeep(), 300);
                        this.flags.tenSecPlayed = true;
                        this.updateUI();
                    });
                } else if (!this.flags.tenSecPlayed && rem <= tenMs) {
                    this.playShortBeep();
                    setTimeout(()=> this.playShortBeep(), 300);
                    this.flags.tenSecPlayed = true;
                }
                if (!this.flags.endPlayed) {
                    this.scheduleBeepAt(rem, ()=>{
                        this.playLongBeep();
                        this.flags.endPlayed = true;
                        this.state = 'finished';
                        this.clearScheduled();
                        this._stopTick();
                        this.updateUI();
                        this.onFinish();
                    });
                }
            }

            _startTick() {
                if (this.intervalHandle) return;
                this.intervalHandle = setInterval(()=>{
                    const now = performance.now();
                    const elapsed = now - this.lastStartTimestamp;
                    this.remaining -= elapsed;
                    this.lastStartTimestamp = now;
                    if (this.remaining <= 0) {
                        this.remaining = 0;
                        if (this.state !== 'finished') {
                            this.state = 'finished';
                            this.clearScheduled();
                            this._stopTick();
                            this.flags.endPlayed = true;
                            this.updateUI();
                            this.onFinish();
                        }
                    }
                    this.updateUI();
                }, this.tickInterval);
            }

            _stopTick() {
                if (this.intervalHandle) {
                    clearInterval(this.intervalHandle);
                    this.intervalHandle = null;
                }
            }

            pause() {
                if (this.state !== 'running') return;
                this.state = 'paused';
                const now = performance.now();
                const elapsed = now - this.lastStartTimestamp;
                this.remaining -= elapsed;
                if (this.remaining < 0) this.remaining = 0;
                this.clearScheduled();
                this._stopTick();
                this.updateUI();
            }

            resume() {
                if (this.state !== 'paused') return;
                if (this.remaining <= 0) {
                    this.state = 'finished';
                    this.updateUI();
                    return;
                }
                this.state = 'running';
                this.lastStartTimestamp = performance.now();
                this._scheduleFromNow();
                this._startTick();
                this.updateUI();
            }

            reset() {
                this.clearScheduled();
                this._stopTick();
                this.remaining = this.duration * 1000;
                this.state = 'idle';
                this.flags = { startPlayed:false, tenSecPlayed:false, endPlayed:false };
                this.updateUI();
            }

            playShortBeep() { beep.play('short'); }
            playLongBeep() { beep.play('long'); }

            playStartBeep() {
                if (!this.flags.startPlayed) {
                    this.playShortBeep();
                    this.flags.startPlayed = true;
                    this.updateUI();
                } else {
                    this.playShortBeep();
                }
            }
            
            playTenSecBeep() {
                if (!this.flags.tenSecPlayed) {
                    this.playShortBeep();
                    setTimeout(()=> this.playShortBeep(), 300);
                    this.flags.tenSecPlayed = true;
                    this.updateUI();
                } else {
                    this.playShortBeep();
                    setTimeout(()=> this.playShortBeep(), 300);
                }
            }
            
            playEndBeep() {
                if (!this.flags.endPlayed) {
                    this.playLongBeep();
                    this.flags.endPlayed = true;
                    this.updateUI();
                } else {
                    this.playLongBeep();
                }
            }
        }

        // Define timers
        const definitions = [
            { id: 't1', label: 'Babak 1 — Argumentasi Pembuka (2:00)', duration: 120 },
            { id: 't2', label: 'Babak 2 — Sanggahan Utama (1:30)', duration: 90 },
            { id: 't2b', label: 'Babak 2 — Durasi Sanggahan (30s)', duration: 30 },
            { id: 't3a', label: 'Babak 3 — Diskusi (1:00)', duration: 60 },
            { id: 't3b', label: 'Babak 3 — Penyampaian Argumen (1:30)', duration: 90 },
            { id: 't4', label: 'Babak 4 — Closing (1:30)', duration: 90 }
        ];

        // Create timer instances
        const timers = {};
        definitions.forEach(def=>{
            const t = new DebateTimer({
                id: def.id,
                label: def.label,
                duration: def.duration,
                onFinish: ()=> {
                    console.log(def.label + ' finished.');
                }
            });
            timers[def.id] = t;
        });

        // Expose timers for debugging
        window.debateTimers = timers;
    </script>
</body>
</html>

