<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Debate Timers — Multi Timer with Whistle Sound (Durasi Suara Diperpanjang)</title>
<style>
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:#f6f7fb; color:#111; margin:18px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px;}
  h1{font-size:18px;margin:0}
  .clock{font-weight:600;color:#2b2b2b}
  .container{display:grid;grid-template-columns:repeat(auto-fit,minmax(340px,1fr));gap:12px}
  .card{background:#fff;border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(13,21,32,0.06)}
  .title{font-weight:700;margin:0 0 6px 0}
  .meta{font-size:13px;color:#666;margin-bottom:8px}
  .big-time{font-size:28px;font-weight:700;margin:6px 0}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  button{padding:8px 10px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}
  button.primary{background:#2b6df6;color:#fff;border:0}
  button.warn{background:#ffb020;color:#fff;border:0}
  .small{font-size:12px;padding:6px 8px}
  .status{margin-top:8px;font-size:13px}
  .indicator{display:inline-block;padding:6px 8px;border-radius:999px;font-weight:600}
  .playing{background:#e6fff3;color:#057a48}
  .idle{background:#fff6e6;color:#8a5b00}
  .muted{background:#f4f4f5;color:#6b6b6b}
  .event-list{font-size:13px;margin-top:8px}
  .footer{margin-top:16px;font-size:13px;color:#444}
  .btn-ghost{background:transparent;border:1px dashed #ccc}
  @media (max-width:420px){.big-time{font-size:22px}}
</style>
</head>
<body>

<header>
  <h1>Debate Timers — Multi Sound Scheduler (Whistle Sound Durasi Diperpanjang)</h1>
  <div class="clock" id="liveClock">--:--:--</div>
</header>

<div class="container" id="timersContainer">
  <!-- Cards generated by JS -->
</div>

<div style="margin-top:14px" class="footer">
  Tips: Tekan Start -> timer akan langsung bunyi whistle pendek (1.2 detik). Pada sisa 10 detik akan terdengar 2× bunyi whistle pendek (terpisah 300ms, masing-masing 1.2 detik). Pada akhir akan terdengar bunyi whistle panjang (2.5 detik). Pause/Resume menjaga jadwal beep tanpa duplikasi.
</div>

<script>
// ==== Live Clock ====
function updateLiveClock() {
  const now = new Date();
  document.getElementById("liveClock").textContent = now.toLocaleTimeString("id-ID");
}
setInterval(updateLiveClock, 1000);
updateLiveClock();

// ==== Sound Functions (whistle-like) dengan durasi diperpanjang ====
class WhistleBeep {
  constructor() {
    this.ctx = null;
  }
  init() {
    if (this.ctx) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    if (!AudioContext) {
      console.warn('WebAudio not supported in this browser.');
      return;
    }
    this.ctx = new AudioContext();
  }
  play(type = "short") {
    this.init();
    if (!this.ctx) return;
    const ctx = this.ctx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.connect(gain);
    gain.connect(ctx.destination);

    osc.type = "square";
    osc.frequency.value = 1000;

    // Durasi suara diperpanjang 1 detik dari sebelumnya
    let duration = 1.2; // short beep (sebelumnya 0.2s + 1s)
    if (type === "double") duration = 1.5; // double beep (sebelumnya 0.5s + 1s)
    if (type === "long") duration = 2.5; // long beep (sebelumnya 1.5s + 1s)

    gain.gain.setValueAtTime(0.2, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);

    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + duration);
  }
}

const beep = new WhistleBeep();

// ==== Timer class ====
class DebateTimer {
  constructor(opts) {
    this.id = opts.id;
    this.label = opts.label;
    this.duration = opts.duration; // seconds
    this.remaining = this.duration * 1000; // ms
    this.state = 'idle'; // idle, running, paused, finished
    this.intervalHandle = null;
    this.tickInterval = 200; // ms update UI
    this.onTick = opts.onTick || function(){};
    this.onFinish = opts.onFinish || function(){};
    this.timeoutHandles = []; // scheduled beep timeouts
    this.flags = { startPlayed:false, tenSecPlayed:false, endPlayed:false };
    this.lastStartTimestamp = null; // performance.now() when started/resumed
    this.element = null;
    this.createUI();
  }

  createUI() {
    const container = document.getElementById('timersContainer');
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <div class="title">${this.label}</div>
      <div class="meta">Durasi: <strong>${this.duration} detik</strong></div>
      <div class="big-time" id="${this.id}-time">--:--</div>
      <div class="controls" id="${this.id}-controls"></div>
      <div class="status" id="${this.id}-status"><span class="indicator idle">IDLE</span></div>
      <div class="event-list" id="${this.id}-events"></div>
    `;
    container.appendChild(card);
    this.element = card;
    this.timeEl = card.querySelector(`#${this.id}-time`);
    this.controlsEl = card.querySelector(`#${this.id}-controls`);
    this.statusEl = card.querySelector(`#${this.id}-status`);
    this.eventsEl = card.querySelector(`#${this.id}-events`);

    // Build controls
    const btnStart = this.mkButton('Start', 'primary', ()=>this.start());
    const btnPause = this.mkButton('Pause', '', ()=>this.pause());
    const btnResume = this.mkButton('Resume', '', ()=>this.resume());
    const btnReset = this.mkButton('Reset', 'btn-ghost', ()=>this.reset());
    const btnPlayStart = this.mkButton('Play start beep', '', ()=>this.playStartBeep());
    const btnPlayTen = this.mkButton('Play 10s beeps', '', ()=>this.playTenSecBeep());
    const btnPlayEnd = this.mkButton('Play end beep', '', ()=>this.playEndBeep());

    [btnStart, btnPause, btnResume, btnReset, btnPlayStart, btnPlayTen, btnPlayEnd].forEach(b=>this.controlsEl.appendChild(b));
    this.updateUI();
  }

  mkButton(label, cls, cb) {
    const b = document.createElement('button');
    b.textContent = label;
    if (cls) b.classList.add(cls);
    b.classList.add('small');
    b.addEventListener('click', cb);
    return b;
  }

  formatRemaining(ms) {
    if (ms < 0) ms = 0;
    const s = Math.ceil(ms/1000);
    const mm = Math.floor(s/60);
    const ss = s % 60;
    return `${mm}:${ss.toString().padStart(2,'0')}`;
  }

  updateUI() {
    this.timeEl.textContent = this.formatRemaining(this.remaining);
    if (this.state === 'idle') {
      this.statusEl.innerHTML = `<span class="indicator idle">IDLE</span>`;
    } else if (this.state === 'running') {
      this.statusEl.innerHTML = `<span class="indicator playing">RUNNING</span>`;
    } else if (this.state === 'paused') {
      this.statusEl.innerHTML = `<span class="indicator muted">PAUSED</span>`;
    } else if (this.state === 'finished') {
      this.statusEl.innerHTML = `<span class="indicator idle">FINISHED</span>`;
    }
    const evs = [
      `Start beep: ${this.flags.startPlayed ? 'played' : 'pending'}`,
      `10s beeps: ${this.flags.tenSecPlayed ? 'played' : 'pending'}`,
      `End beep: ${this.flags.endPlayed ? 'played' : 'pending'}`
    ];
    this.eventsEl.innerHTML = evs.join(' • ');
  }

  scheduleBeepAt(relMs, fn) {
    if (relMs < 0) return;
    const handle = setTimeout(()=>{
      fn();
      this.timeoutHandles = this.timeoutHandles.filter(h=>h !== handle);
    }, relMs);
    this.timeoutHandles.push(handle);
  }

  clearScheduled() {
    this.timeoutHandles.forEach(h=>clearTimeout(h));
    this.timeoutHandles = [];
  }

  start() {
    if (this.state === 'running') return;
    if (this.state === 'finished' || this.state === 'idle') {
      this.flags = { startPlayed:false, tenSecPlayed:false, endPlayed:false };
      this.remaining = this.duration * 1000;
    }
    this.state = 'running';
    this.lastStartTimestamp = performance.now();
    if (!this.flags.startPlayed) {
      this.playStartBeep();
      this.flags.startPlayed = true;
    }
    this.clearScheduled();
    this._scheduleFromNow();
    this._startTick();
    this.updateUI();
  }

  _scheduleFromNow() {
    const rem = this.remaining;
    const tenMs = 10000;
    if (!this.flags.tenSecPlayed && rem > tenMs) {
      this.scheduleBeepAt(rem - tenMs, ()=> {
        this.playShortBeep();
        setTimeout(()=> this.playShortBeep(), 300);
        this.flags.tenSecPlayed = true;
        this.updateUI();
      });
    } else if (!this.flags.tenSecPlayed && rem <= tenMs) {
      this.playShortBeep();
      setTimeout(()=> this.playShortBeep(), 300);
      this.flags.tenSecPlayed = true;
    }
    if (!this.flags.endPlayed) {
      this.scheduleBeepAt(rem, ()=>{
        this.playLongBeep();
        this.flags.endPlayed = true;
        this.state = 'finished';
        this.clearScheduled();
        this._stopTick();
        this.updateUI();
        this.onFinish();
      });
    }
  }

  _startTick() {
    if (this.intervalHandle) return;
    this.intervalHandle = setInterval(()=>{
      const now = performance.now();
      const elapsed = now - this.lastStartTimestamp;
      this.remaining -= elapsed;
      this.lastStartTimestamp = now;
      if (this.remaining <= 0) {
        this.remaining = 0;
        if (this.state !== 'finished') {
          this.state = 'finished';
          this.clearScheduled();
          this._stopTick();
          this.flags.endPlayed = true;
          this.updateUI();
          this.onFinish();
        }
      }
      this.updateUI();
    }, this.tickInterval);
  }

  _stopTick() {
    if (this.intervalHandle) {
      clearInterval(this.intervalHandle);
      this.intervalHandle = null;
    }
  }

  pause() {
    if (this.state !== 'running') return;
    this.state = 'paused';
    const now = performance.now();
    const elapsed = now - this.lastStartTimestamp;
    this.remaining -= elapsed;
    if (this.remaining < 0) this.remaining = 0;
    this.clearScheduled();
    this._stopTick();
    this.updateUI();
  }

  resume() {
    if (this.state !== 'paused') return;
    if (this.remaining <= 0) {
      this.state = 'finished';
      this.updateUI();
      return;
    }
    this.state = 'running';
    this.lastStartTimestamp = performance.now();
    this._scheduleFromNow();
    this._startTick();
    this.updateUI();
  }

  reset() {
    this.clearScheduled();
    this._stopTick();
    this.remaining = this.duration * 1000;
    this.state = 'idle';
    this.flags = { startPlayed:false, tenSecPlayed:false, endPlayed:false };
    this.updateUI();
  }

  playShortBeep() { beep.play('short'); }
  playLongBeep() { beep.play('long'); }

  playStartBeep() {
    if (!this.flags.startPlayed) {
      this.playShortBeep();
      this.flags.startPlayed = true;
      this.updateUI();
    } else {
      this.playShortBeep();
    }
  }
  playTenSecBeep() {
    if (!this.flags.tenSecPlayed) {
      this.playShortBeep();
      setTimeout(()=> this.playShortBeep(), 300);
      this.flags.tenSecPlayed = true;
      this.updateUI();
    } else {
      this.playShortBeep();
      setTimeout(()=> this.playShortBeep(), 300);
    }
  }
  playEndBeep() {
    if (!this.flags.endPlayed) {
      this.playLongBeep();
      this.flags.endPlayed = true;
      this.updateUI();
    } else {
      this.playLongBeep();
    }
  }
}

// --- Define timers ---
const definitions = [
  { id: 't1', label: 'Babak 1 — Argumentasi Pembuka (2:00)', duration: 120 },
  { id: 't2', label: 'Babak 2 — Sanggahan Utama (1:30)', duration: 90 },
  { id: 't2b', label: 'Babak 2 — Durasi Sanggahan (30s)', duration: 30 },
  { id: 't3a', label: 'Babak 3 — Diskusi (1:00)', duration: 60 },
  { id: 't3b', label: 'Babak 3 — Penyampaian Argumen (1:30)', duration: 90 },
  { id: 't4', label: 'Babak 4 — Closing (1:30)', duration: 90 }
];

const timers = {};
definitions.forEach(def=>{
  const t = new DebateTimer({
    id: def.id,
    label: def.label,
    duration: def.duration,
    onFinish: ()=> {
      console.log(def.label + ' finished.');
    }
  });
  timers[def.id] = t;
});

window.debateTimers = timers;
</script>

</body>
</html>
